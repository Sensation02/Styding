using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
/*

Збирач сміття (Garbage Collector)

Перш за все треба пригадати які типи перемінних в нас є:
1. Ссилочні (референс тайп)
2. Значимі типи (велью тайп)

З цим, відповідно, пов"язано який тип пам"яті є:
1. Куча (хіп) - вся оперативка, але повільно (щось велике, класи доприкладу, структури, string, object)
2. Стек - обмежений по розміру, але швидкий (int або всі чисельні, char, bool) 

Але і кучі є двох видів:
1. Звичайна куча
2. Large object heep - куча великих об"єктів - об"єкти більше 85 мб

Різниця? після оптимізації у великій кучі не відбувається переміщення об"єктів.

Створюючи перемінну, наприклад int i = 7;, і даючи їй ім"я ми ніби даємо ім"я ділянці пам"яті (стек)

Куча невпорядкована пам"ять куди можемо поміщати щось велике,
наприклад клас С якийсь складається з однієї перемінної. В цієї ділянки пам"яті також є певний адрес (ссилка)
і цей адрес ми поміщаємо в ділянку пам"яті стека. Тобто в стек поміщаємо ссилку (адрес) на ділянку пам"яті в кучі

Якщо ми викликаємо якийсь метод в який передаємо нашу перемінну "і", в нас викликається фрейм метода, тобто
в ділянку пам"яті стека куди передають аргумент у вигляді дубліката. 
Це означає, що ми беремо значення з перемінної і передаємо по ссилці в наш метод. Після виконання роботи метода
пам"ять в стеку звільняється, ссилка на екземпляр класа С з методом пропадає, але сам клас все ще в кучі.

Саме для цього і потрібен Garbage Collector, щоб час від часу вичищати пам"ять. Він зупиняє роботу програми,
проходиться по всій кучі, дивиться на об"єкти і якщо немає ссилки на цей об"єкт то цю пам"ять звільняє та
впорядковує ці об"єкти. Для цього і зупиняється виконання програми, без цього будуть виникати конфлікти в програмі.

Також для цього було придумано Покоління: 
0 - покоління 
1 - покоління 
2 - покоління

Це придумано під оператор new, який створений для того щоб виділяти пам"ять в кучі.
Тобто ми створили щось, через new виділили пам"ять в кучі і це щось отримало 0-е покоління.  
Збірник сміття завжди буде перевіряти новачків, тобто 0-е покоління, на наявність ссилки.
Якщо буде ссилка, тоді такому об"єкту буде присвоємо 1-е покоління, решту видаляється. Далі система дивиться чи
достатньо пам"яті, якщо так то збірник зупиняється, якщо пам"яті не вистачає, він починає перевіряти 1-е покоління.
Де є ссилки - переходять у 2-е покоління, немає? - видаляється. Більше 2-го покоління немає. 
Чим свіжіший об"єкт тим частіше буде перевірятися, старі об"єкти рідше будуть перевірятися.

Також треба зазначити що Garbage Collector працює не завжди.

*/
namespace Garbage_Collector
{
    internal class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine(GC.GetTotalMemory(false)); // вивід пам"яті до виконання роботи програми
            // якась ресурсозатратна робота:
            for (int i = 0; i < 10000; i++)
            {
                
                var obj = (object)i;
                int j = (int)obj;
            }

            // також про IDisposable:
            using (var c = new Class1())
            {
                // виконується певна дія
                // після чого буде задіяний метод Disposе
                // закриється поток -0і почиститься пам"ять
            }

            Console.WriteLine(GC.GetTotalMemory(false)); // перевіряємо чи змінився об"єм пам"яті

            GC.Collect(); // запуск збірника, в () вказуємо покоління до якого буде працювати

            Console.WriteLine(GC.GetTotalMemory(false));

            Console.ReadLine();
            // ось така робота збірника:))


            
            
        }
    }
}
