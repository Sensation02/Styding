/* EVENTS ПОДІЯ
   Механіка події 
    Делегат зберігає ссилки на методи а подія це ніби обгортка над делегатом, тобто всередині івента делегат 
    Для чого це? Для того щоб правильно розуміти коли має бути івент, а коли делегат 

    На приклад форми (WPF\WAF) кнопки, тобто коли ми на неї нажимаємо викликається івент і все що підписано на цю подію
    будуть сповіщені що воно виникло і далі піде обробка

    Або, наприклад, дзвінок у школі, який оповіщає всіх у школі що урок закінчився і у всіх буде реакція на цей дзвінок
    буде різною

    Або на ютубі кнопка дзвінка, коли виходить нове відео то приходить сповіщення, що вийшло нове відео і далі
    ми це оброблюємо як ми хочемо

    Так само в програмуванні. Ми створюємо подію, створюємо шаблон оброки цієї події через своєрідний делегат
    і кожний обробник може по своєму відреагувати на цю подію
    
    Сігнатура:
    [modifiers] event [delegate] Name; 

    [delegate] - тип делегата 
    Name; - назва події, наприклад Click - натискання кнопки, Tick - спрацювайння таймера 
    
    Коли що використовувати, в чому їх відмінність?
    Делегат:                                   
    - Якщо ми задіюємо наш код ззовні 
    - Потрібно повертати значення
    - Можливий виклик ззовні
    - Неможу бути викликаний інтерфейсом (тому що він тільки задає щось що немає реалізації)
    - Можна передати в якості параметрів метода

    Івент:
    - Сповіщаємо про подію всім бажаючим
    - Немає значення що потрібно повертати, інакше це не вірно для події, тобто він має тільки сповіщати
    - Викликається тільки зсередини класу де об"явлено подію
    - Подія може бути об"явлена на рівні інтерфейса
     
    Якщо незнаєш, що використовувати, юзай Івент, тоді логіка програми сама тобі підскаже чи він взагалі буде 
    умісним в роботі чи ні
 */


namespace Уроки
{
    internal class Events
    {
        //public delegate void Handler(string alpha, int beta); 
        //делегат на основі якого буде створений івент, Обробник(Handler)
        //public event Handler Stuck;
        //івент з довільним іменем
    }

    //сухий приклад без змісту
    public delegate void Handler(string alpha, int beta);



    class Program
    {
        public static event Handler Stuck;
        //об"явили івент, так само як і в роботі з делегатами, тільки ще є абстракція з івентом
        //навіть видалення слова event нічого не зміниться
        //Event має бути об"явленим всередині класа а не метода

        public delegate void MyDelegate();
        public event MyDelegate Event;
        //на цю подію може зреагувати тільки той метод який відповідає делегату, тобто:
        //Event -> MyDelegate -> MyDelegate();

        public event Action EventAction; //це по суті те саме що вище написано



        static void Main()
        {


            Stuck += ShowPrice; //реєструємо метод в івенті
            Stuck("Text", 100); //подія із беззмістовними параметрами
            Console.ReadLine();

            Person person = new Person
            {
                Name = "Boris"
            };
            //тепер потрібен обробник, треба підписатися на цю подію
            person.GoToSleep += Person_GoToSleep;
            person.DoWork += Person_DoWork;
            //відповідно одразу формується обробник події, яку ми створили в окремому класі
            person.TakeTime(DateTime.Parse("27.12.2018 21:13:01")); //попадаємо сюди
            //спрацьовує наш метод в класі Person, тобто перевіряється година, вона нормальна
            //і обробник події спрацьовує, відбулася подія -> наша людина робить роботу
            person.TakeTime(DateTime.Parse("27.12.2018 4:13:01")); //попали сюди - час менший
            //знову спрацьовує наш метод, година менша, спрацьовує обробник події, тобто відбулася подія
            //він спрацьовує (обробник) і нам каже: "Person asleep."


            //але використаний Action дає дуже мало інформації, він використовується
            //на практиці повинні передаватися якісь конкретні дані, дя цього можна користуватися і Func і Predicate
            //але частіше всього використовується спеціальний EventHandler - так званий шаблон делегата
        }

        #region Delegate&Event_CodeBlog
        private static void Person_DoWork(object? sender, EventArgs e)
        //sender треба привести до типу Person (ім"я класу який ми використовуємо) безпечно!
        //EventArgs e = null
        {
            //Console.WriteLine($"{(Person)sender} doin his job"); - просто так писати НЕБЕЗПЕЧНО, тому робимо так:
            if (sender is Person)
            {
                Console.WriteLine($"{((Person)sender).Name} doin his job");
                //sender -> this -> наш клас де об"явлена подія, але треба привести через (Person)
                //і вказуємо .Name щоб вивелося ім"я
            }
            //тоді ми будемо убезпечені в тому що сюди прийде
        }

        private static void Person_GoToSleep() 
            //обробник події
            //тобто метод який відповідає делегато цієї сигнатури
            //void ... ()
        {
            Console.WriteLine("Person asleep.");
            Console.ReadLine();
        }
        #endregion

        public static void ShowPrice(string alpha, int beta) //метод із підходящою сігнатурою
        {
            Console.WriteLine($"alpha {alpha}, beta {beta}");
        }

        #region delegate&Event_Codaza
        //Ще приклад делегата:

        public delegate int CalculateBonus(Position position);
        //делегат який має зберігати ссилку на метод який приймає (Position position)
        //і нараховує річний бонус (int) при чому для кожної позиції різний бонус
        public CalculateBonus CalculateBonusesForEmployee { get; set; } 
        //проперті з типом нашого делегата і чекаємо що зовнішній код нам дасть метод із заданою сігнатурою
        private void CalculateBonuses(IEnumerable<Employee> employees) 
            //в цьому методі отримуємо список співробітників 
        {
            foreach (Employee employee in employees) 
                //.. і в циклі починаємо нараховувати бонуси для кожного співробітника
            {
                employee.Bonus = CalculateBonusesForEmployee(employee.Position);
            }
        }
        //таким чином ми делегуємо розрахунок кода ззовні, ми не сповіщаємо а не робимо із цього подію
        //ми делегуємо, просимо код ззовні допомогти нам з розрахунком в бонусі співробітникам за рік
        //тобто івенту тут немає місце

        //приклад Івента з тими ж співробітниками
        //тут нам позиції співробітників не потрібні, ми будемо вітати співробітників зі святами

        public delegate void Congratulate(int employeeId);
        //делегат з іменем "вітаємо"
        public event Congratulate Congratulated;
        //подія на раніше об"явленому делегаті

        public void CongratulateEmployees(IEnumerable<Employee> employees)
        {
            foreach (Employee employee in employees)
            {
                //тут код без логіки - тобто бізнес логіка пов"язана із привітанням співробітників
                //наприклад смс, або повідомлення на пошту з привітанням та видачею, наприклад,
                //путівок у санаторій

                //сповіщення:
                Congratulated(employee.Id);
                //сповіщаємо всіх що конкретний співробітник з тим чи іншим святом поздоровлений
                //цих "всіх" може і не бути, головне те що ми привітали))
                //тобто ми не залежимо від втручання ззовні
            }
        }
        //івенти та інтерфейси:
        public interface IManager
        {
            event Congratulate Congratulated;
            //тут event вже видалити неможна
        }
        #endregion
    }


    //Ще приклад делегата
    enum Position //позиції робітників
    { 
        Manager,
        ViceProsident
    }
    class Employee //клас працівника і скільки який працівник отримує бонуса в кінці року
    {
        public Position Position { get; set; } //проперті позиції
        public int Bonus { get; set; } //річний бонус

        public int Id { get; set; } //ідентифікатор в БД
    }

    }
