using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Diagnostics;
using System.Reflection;
using Уроки;
using System.ComponentModel.DataAnnotations;
using BenchmarkDotNet.Attributes;


namespace Уроки
{
    /*
     *  Структури
     *   - являються значимим типом і не можуть бути успадковані  
     *   структура є кращим вибором якщо ми описуємо наприклад якусь "точку"
     *   Працюємо в парі з бенчмарком (там ми виясняємо швидкість роботи класу і структури)
     * 
     * 
     *  Порівнюватися буде з класом:
     *  структура бо своєму функціоналу схожа на клас але різниця заключається в тому як ми зберігаємо дані в пам"яті
     *  
     *  клас це ссилочний тип а структура це значимий тип
     *  
     *  структуру добре використовувати коли є якась дуже не велика кількість даних, тобто вони прості
     *  і нам не потрібно використовувати ООП, і так можна виграти у швидкодії
     *  якщо ж в нас багато полів і властивостей, то структура навпаки буде працювати повільніше
     *  і тоді нам краще використовувати клас
     *  ну якщо вже дуууже треба, то використовуємо ключове слово IN
     */

    public class ClassPoint //нагадуємося що це ссилочний тип (куча)
    {
        public int X { get; set; }
        public int Y { get; set; }

        public void Print()
        {
            Console.WriteLine($"X:{X} Y:{Y}");
        }
    }

    public struct StructPoint : IInterface//(стек)
    {
        public int X { get; set; }
        public int Y { get; set; }

        public void Print()
        {
            Console.WriteLine($"X:{X} Y:{Y}");
        }
        public void Foo()
        {
            var t = X + Y;
        }
    }

    interface IInterface
    {
        void Foo();
    }

    internal class leson
    {
        static void Foo(ClassPoint classPoint)
        {
            classPoint.X++;
            classPoint.Y++;
        }
        static void Bar(StructPoint structPoint)
        {
            structPoint.X++;
            structPoint.Y++;
        }
        static void Main(string[] args)
        {
            ClassPoint classPoint = new ClassPoint();//повільніше
            //без new ClassPoint в дебагі буде null тому що ми посуті нікуди ще не ссилаємося
            StructPoint structPoint = new StructPoint();//швидше
            //а тут в дебагі 0 (нулі) тому що це дефолтне значення
            // new StructPoint()  - не означає що буде створено об"єкт в кучі, без цього в..
            //Console.WriteLine(structPoint.X); ..помилка, в структурі поінт не було ініціалізовано значення

            Foo(classPoint); //тут вже буде 1
            Bar(structPoint); // тут 0
            //нулі тому що дані зі структури копіюються в екземпляр,
            //тобто в дебагі було 1, потім скопіювалося і стало 0 зі структури 
            //тоообто екземпляр структури в методі і екземпляр структури (що вище) це два різних екземпляра

            //з класом все по іншому екземпляр класу в методі отримує дані і відправляє їх в кучу
            //на виході ми торимуємо 1 (одиниці) тому що ми посилаємося на ті дані в кучі, а там вже 1

            //робота з інтерфейсом:
            IInterface myInterface = structPoint; //присвоюємо в об"єкт інтерфейсу структуру 
            //тобто можемо в структурі реалізувати інтерфейс


            //в структурі не працюють принципи ООП, тобто:
            // - не підртимується наслідування (окрім інтерфейсів)
            // - немає модифікаторів доступа протектед для полів властивостей та методів
            // - немає віртуал і оверрайд (для перевизначння роботи методів класу при наслідування та реалізації поліморфізму)
            // - в public int X { get; set; } неможна присвоювати дані напряму, тобто - = 1; (ініціалізація властивостей)
            // - неможна створювати конструктори без параметрів (тільки з параметрами всередині)
            //якби ми це зробили в класі то ми б втратили можливість працювати з конструктором без параметрів
            //взагалі конструктор без параметрів там є і він реалізує дефолтне значення, в нашому випадку тут будут 0 (нулі)

            //у класів в мові С# є так званий фіналайзер ~ClassPoint(){} (виглядає як деструктор в мові С++)
            //цей об"єкт викликається тоді коли працює збірник мусора
            //і в класах ми можемо переписати його роботу, що не можемо зробити в структурі
            //тому що він там впринципі не викликається так як вони не в кучі

            //на співбесіді можуть запитати про роботу методі Equals
            //метод який виясняє чи вірні класи і структури

            ClassPoint classPoint1 = new ClassPoint { X = 2, Y = 3 };
            ClassPoint classPoint2 = new ClassPoint { X = 2, Y = 3 };
            bool classesAreEqual = classPoint1.Equals(classPoint2);
            //класи не рівні (false), тому що тут він порівнює не значення в класах, а їхні ссилки (а тут вони різні)
            //в класі це можна змінити за допомоги оверрайд
            
            StructPoint structPoint1 = new StructPoint { X = 2, Y = 3 };
            StructPoint structPoint2 = new StructPoint { X = 2, Y = 3 };
            bool structsAreEqual = structPoint1.Equals(structPoint2);
            //структури рівні (true), тому що порівнюються дані в структурах
        }

    }
}