namespace Навчання_ООП
{

    class Program
    {
        static void Main()
        {
            RobotBase bot = new Bot();
            //об"єкт класу має доступ до полів та методів які нам доступні по модифікатору доступа
            //можна також звертатися напряму до базового класу

            bot.Name = "Bazzil";
            bot.Weight = 800;
            bot.Coordinates = new byte[]{ 0, 0, 0 };

            //надали характеристики нашому роботу, це поля, які нам доступні по модифікатору доступа
            //далі з цими характеристиками ми можемо робити все, що ми хочемо

            //написаний код дуже "грубий" і в ньому розібратися, особливо через якийсь час, буде дуже важко
            //особливо якщо написано дуже багато, наприклад створено таким чином багато об"єктів класу
            //і для простоти роботи й існує концепція ООП



            bot.SetHeight(200); //через метод задали висоту нашого робота

            /* Тепер будемо все робити через методи(функції). 
             * Переведемо наші поля в private, 
             * відмітимо те що через об"єкт класу ми вже не можемо напряму звернутися до наших полів, 
             * це вже треба робити через методи */

            bot.SetName("Nata");
            bot.SetWeight(400);
            bot.SetCoordinates(new byte[] { 1, 1, 1 });

            bot.PrintValues(); //виводимо наші параметри у консоль
            Console.WriteLine(); //пробіл
            RobotBase.PrintRobotCount(); //виводимо к-сть наших роботів


            /* Далі в базовому класі ми перевели наші поля в private
             * і додали конструктор, через яким ми маємо доступ до полів, але не просто доступ
             * ми маємо можливість на етапі створення об"єкта класу вже вказувати необхідні нам дані */

            RobotBase bot1 = new Bot("Bazzil");
            bot1.Weight = -3; //через об"єкт класу можна звертатися до аксессора
            Console.WriteLine(bot1.Weight); 
            //на виході "1" тому що ми задали вагу -3, якби було 100 то вивело б 100 (дивися базовий клас)

            /* До новоствореного класу (успадкованого від Robot) створюємо об"єкт і використовуємо його функціонал
             * який пов"язаний із батьківським так і новим */
            RobotKiller killer = new RobotKiller("Killer", 200, new byte[] {1,2,2});
            killer.Health = 100; //додали параметрів до аксессера
            killer.LazerAttak(); //використали метод "лазерної атаки"
            killer.PrintKillerValues(); //використання метода наступника

            /* Створюємо список наших роботів: */
            List<RobotKiller> robots = new List<RobotKiller>();
            robots.Add(new RobotKiller("Dima", 400, new byte[] { 1, 3, 4 }, 100));
            robots.Add(new RobotKiller("Denis", 300, new byte[] { 2, 3, 3 }, 100));
            robots.Add(new RobotKiller("Viktor", 350, new byte[] { 3, 5, 1 }, 100));
            //кожний елемент який ми додаємо у список має бути об"єктом нашого класу RobotKiller

            //Тепер об"єкт з іменем Dima будемо обробляти як об"єкт класу RobotBase
            RobotBase newRobot = null;
            foreach (RobotKiller item in robots)
            {
                if (item.Name == "Dima") //перевірка
                {
                    newRobot = item as RobotBase;
                    //тобто до цього об"єкта ми будемо відноситися як до об"єкта класу RobotBase
                    //використовуючи as
                    //і в цього об"єкта вже не буде методів і полів тощо які є в RobotKiller
                    //наприклад метод LazerAttak буде не доступним
                }
                //оператор is перевіряє чи належить наш об"єкт до класу RobotKiller
                Console.WriteLine(item is RobotBase);
                //true - так як RobotBase це батьківський клас від якого походить RobotKiller
                //тобто is перевіряє чи належить тип нашого об"єкт до іншого типу 
                //int is float - false - наприклад
            }

            //віртуальні методи (Поліморфізм)
            bot.PrintValues(); //виводить без Health
            killer.PrintValues(); //виводить з Health, так як ми через virtual override доповнили метод
            //метод який ми переписали за допомогою virtual override має виконувати однакову дію
            //PrintValues виводив інформацію про бота, він і має цю інформацію виводити, а не щось інше
            //тобто метод вивода інформації ми доповнили ще чимось, що потребує вивода
            //взагалі такий метод можна і переписати, але це буде виглядати погано


            //абстрактні класи, методи
            //на їх основі ми описуємо функціонал який ми хочемо реалізувати в нступниках
            //також на їх основі не можна створювати об"єкти класа
            //наш загальний клас ми робимо abstract, відповідно всім об"єкти цього класу будуть видавати помилку
            //їх ми також переробляємо, тобто RobotBase в Bot

            Bot bot2 = new Bot("Bot", 800, new byte[] {7,8,4});
            bot2.PrintValues(); //цей метод ми також робимо абстрактним

            //Інтерфейси
            bot2.Run();
            //в інтерфейсах ми пишемо те що ми хочемо реалізувати в майбутньому
            //і в даному випадку ми написали інтерфейс який описує біг нашого робота, задали проперти швидкості
            //вже у самому нашому базовому, абстрактному класі ми описали його
            //і наші нащадки вже можуть через Наслідування ним користуватися

            //або ще прижка:
            bot2.Jump();
            //ці інтерфейси в даному випадку описують базові дії наших роботів, ці базові дії в майбутньому можна 
            //буде реалізувати не тільки в роботах, а й наприклад в класах Людини тощо

            //перегрузка методів або функцій
            //за їх рахунок ми можемо мати один і той самий метод але він буде відрізнятися кількістю параметрів
            //щось схоже на конструктори 
            Multiply(4, 2);
            Multiply(5, 1, 3);
            //та ж назва - різна к-сть параметрів та виконання
            //навіть банальний WriteLine це перегружений метод

            bot2.SetValues("OMG ROBAAAT", 1000); //реалізували перегружений метод

            //Enum - перечислення
            //по нашому класу створили перечислення, якого "типу" наш робот
            //створили проперті та конструктори з новим параметром
            RobotKiller robotKiller = new RobotKiller("BAZILL", 600, new byte[] { 5, 1, 8 }, 1000, Type.Hero);
            //відповідно буде виводитися та інфа яка супроводжується з нашим перечисленням
            //а власне - This robaaat is HEEEEROOO

        }
        //перегрузка методів:
        public static void Multiply(int a, int b)
        {
            int res = a * b;
            Console.WriteLine("Result " + res);
        }
        public static void Multiply(int a, int b, int c)
        {
            int res = a * b + c;
            Console.WriteLine("Result " + res);
        }
        //і таких перегрузок може бути велика кількість
    }
}