/*
    Конкурентність - це коли два і більше процесів, і вони конкурують за одні і ті ж ресурси компа, але
    між собою не конкурують і один на одного не впливають. Приклад це виконання двох конкурентних засобів
    і між собою вони не взаємодіють, конкурують за роботу монітора і можуть між собою переключатися.

    Паралельне виконання - більш вузьке поняття. Коли всередині програми можемо виділити декілька окремих частин 
    які можуть працювати між собою ніяк не пов"язано і вкінці зійтися й видати спільний результат.

    Багатопотоковість - це коли з декількох потоків є головний, інтерфейса, і створити окрем потік 
    вичислення даних який буде працювати паралельно і вони можуть синхронізуватися й обмінюватися даними. 
    Наприклад відбулася якась подія і почали приходити якісь дані, тобто як паралельні потоки тільки зв"язані
    між собою і обмінюються даними між собою.

    Асинхронність - це коли є основний потік від якого відгалужується ще один, гілка, в якої є певні задачі після 
    виконання яких ця гілка закінчується, а основний поток продовжує своє виконання.
    Задача це виокремлена частина коду, як функція, яка може виконуватися окремо від основного потока і яка
    буде виконуватися і після закінчення основного потоку
    
    Процес створення потоку є досить ресурсозатратним процесом, її треба застосовуватися тільки тоді коли є
    якась довга паралельна синхронна операція з якимись додатковими завданнями.

    А асинхронність це коли вже є певний набір готових потоків які ми беремо ніби в оренду, щось обрахували
    і повернулися назад в основний поток. І ці готові потоки знаходяться в призупиненому стані, а коли виникає
    в них потреба вони застосовуються. Це має як і достатки так і недостатки.
    
 */

namespace Навчання_ООП
{
    class Program
    {
        static void Main(string[] args)
        {
            //багатопоточність:
            #region BasicThread
            //для виокремлення потоку використовуємо клас:
            //Thread thread = new Thread(new ThreadStart(DoWork)); //поток без параметрів
            //thread.Start();

            //Thread thread2 = new Thread(new ParameterizedThreadStart(DoWork2)); //поток з параметрами
            ////при чому тут спрацьовує тільки тип даних object, це є мінусом
            //thread2.Start(int.MaxValue);

            //int j = 0;
            //for (int i = 0; i < 10; i++)
            //{
            //Console.WriteLine("Main");
            //}
            //це базовий рівень створення потоків,
            //в любому випадку це треба робити тільки тоді коли є нагальна потреба в цьому
            #endregion

            #region Async/await
            //викликаємо наш асонхронний метод синхронно:
            Console.WriteLine("Begin Main");
            DoWorkAsync(); 
            //код завжди виконується по порядку, асинхрон написаний швидше тому спочатку пропрацює асинхронний код
            //а вже потім мейн код
            Console.WriteLine("Continue Main");

            for (int i = 0; i < 10; i++)
            {
                Console.WriteLine("Main");
            }
            //DoWorkAsync(); і цикл for будуть працювати асинхронно
            Console.WriteLine("End Main");
            #endregion

            #region More async await
            //наприклад ми хочемо зберегти дані у файл, довгий процес...
            var result = SaveFileAsync("d:\\test.txt."); //асинхронний метод
            //і після виконання ми можемо вводити текст в консоль відразу
            var input = Console.ReadLine();
            Console.WriteLine(result.Result); //результат результата) тому що буде повертати Таск булл
                                              //на виході булевий результат виконаної роботи
            #endregion

            //Про багатопоточність: Наприклад сказали викопати яму і треба розуміти, якщо ми розпаралелюємо процес то це не просто так
            //і якщо операція маленька, то не треба виділяти поток, бо буде виконуватися довше чим потрібно
            //вдвох копати зручно, але якщо буде 50 людей буде навпаки повільніше

            //Декілька потоків можуть звертатися до одних і тих же ресурсів, коли декілька потоків можуть змінити одну
            //і ту ж перемінну, якусь глобальну або ссилочний тип, коли вона одна десь в кучі

            //якщо ми хочемо щоб якась ділянка коду була доступна тільки для одного потока, треба цю ділянку
            //обгорнути локером lock(locker) {} - ссилочний тип
            //тобто коли на якомусь етапі виконання об"єкт звертається до ділянки з локером він не зможе 
            //ним скористатися, тому що він буде зайнятим іншим потоком

            //Дедлок: це коли два потоки залежать один від одного

            //наприклад в нас є два методи M1 та M2 які використовують спільні дані і не можу ніяк дійти до умови вихода
            //і вони починаються один одному мішати
            //якщо вони будуть виконуватися послідовно то проблем не буде, а якщо вони стають асинхронними
            //вони починаються перетягувати цю глобальну перемінну туди сюди і не можуть дійти до кінця

            Console.ReadLine();
        }

        public static int i1 = 10;
        static void M1()
        {
            for (int i = 0; i <= i1; i++)
            {

            }
        }
        static void M2()
        {
            for (int i = i1; i >= i1; i--)
            {

            }
        }


        //object locker:
        public static object locker = new object();

        //обгортка синхронності для метода збереження у файл
        static async Task<bool> SaveFileAsync(string path)
        {
            var result = await Task.Run(() => SaveFile(path));
            return result;
            //ми очікуємо виконання SaveFile і повертаємо результат в метод в мейні
        }
        //метод збереження тексту у файл
        static bool SaveFile(string path)
        {
            var random = new Random();
            var text = "";
            for (int i = 0; i < 50000; i++)
            {
                text += random.Next();
            }
            using (var sw = new StreamWriter(path, false, System.Text.Encoding.UTF8))
            {
                sw.WriteLine();
            }
            return true;
            ;
        }


        //для використання асинхронності має в параметрі повертатися: Task або Task<int> 
        static async Task DoWorkAsync()
        //static тут не обов"язково, але використовуємо тому що наші методи такі
        //async - ключове слово означає що метод асинхронний
        //GetTaskAsync - до робочої назви метода додаємо Async
        {
            Console.WriteLine("Begin async");
            await Task.Run(() => DoWork());
            //await - інше ключове слово для асинхронності,
            //тобто щоб спрацювала подальша команда ми чекаємо поки виконається та частина коду
            //яка стоїть одразу після нашого await:
            //Task.Run(() => DoWork()); - виклик метода
            //при чому продовжується виконання кода в осноному потоці Main (цикл for)
            Console.WriteLine("End async");
            //при чому await може бути тільки в async методах, а Main не може бути async
            //якщо в нашому методі DoWork(int max) тоді DoWorkAsync(int max) і тоді в Main має бути наприклад DoWorkAsync(100); ітд
        }

        static void DoWork()
            //якийсь собі метод з якоюсь роботою, тривалою
        {
            for (int i = 0; i < 10; i++)
            {
                Console.WriteLine("DoWork");
            }
        }
        static void DoWork2(object max)
        {

            int j = 0;
            for (int i = 0; i < (int)max; i++)
            {
                j++;
                if (j % 10000 == 0)
                {
                    Console.WriteLine("DoWork 2");
                }
            }
        }
    }
}